https://zhuanlan.zhihu.com/p/184618651

CRUD模式的本质
要理解CQRS模式，我们先思考CRUD模式本质是什么。

CRUD代表的四个动作：Create Read Update Delete，其中有三个是变化相关的：Create Update Delete，而这三个动作抽象的是事物从创生到毁灭的整个生命周期，比如一个用户被创建出来、用户的信息随着时间推移发生变化、最终由于某些原因被手动或自动的删除掉。

而Read代表对事物当前状态的观测，观测的结果就是软件的业务价值，这个结果传达的信息可以影响后续人或事的发展。更高阶的Read，比如对结果数据施以大数据分析或机器学习手段，得出从海量信息中提取出的模型和规律，是信息进化到更高维度的表现——"知识"，知识能够预测未来的趋势、指导未来的行为。

既然"CUD"是对事物变化的生命周期过程的抽象，为什么说CRUD模型是静态视角呢？因为每个动作都相对独立，并没有体现当"CUD"发生时，又会对其他事物产生什么样的影响。

我们极力避免"耦合"，但世间万物一定是彼此相关联的。软件代表事物在计算机中的模拟，那么当模拟的事物复杂到一定程度时，互相影响是必然的。

当事物互相影响的复杂度大于事物自身生命周期维护的复杂度时，CRUD就体现出其局限性了。我们用各种RPC调用来互相通知产生的影响、或用消息队列到处传播自身的变化，最终整个软件系统变地嘈杂喧嚣。

CQRS模式带来了什么
CQRS的第一层意思：命令与查询的分离。CRUD模式中的Create、Update、Delete都可以归类为"命令（Command）"，与查询（Query）操作完全隔离。

这里的隔离不同于CRUD模型实现时的读写分离：将数据库从库标识为读库，select语句通过手动的方式或者切面编程，转移到从库执行。

CQRS的查询指的是在单独的查询组件读取当前状态的数据视图，压根没有主库从库的概念，写操作与读操作所对应的数据库是异构的：写进去的是命令对应的事件；读出来的是经历N个事件之后，数据的当前状态视图。

CQRS一般是结合另一种机制，事件溯源（Event Sourcing），共同实现基于事件驱动的软件系统的（CRQS还有一种不太常用的State Based表现形式，这里不讨论）。系统并不直接写入、更新数据本身，而是不停地追加事件。从当前时间之前发生的所有事件，来推断数据的当前状态，而这个当前状态一般会存储在视图库中以提高查询效率。

因此，基于事件驱动避免了轮询和广播数据本身，系统内的通信仅仅是时时刻刻发生的事件，这与真实的世界是一致的，我们通常会因为时时刻刻遇到的事件来决定下一步做什么的，所以说CQRS是以动态视角来看待业务的，而不是CRUD模式关注单个Request-Response的静态视角。事件被底层的消息队列统一调度协调，各个子系统只需把感兴趣的事件追加到自己数据库中，并计算出最新的数据视图，如有必要再产生另一个事件。如果把所有事件根据时间戳排序，能够清晰的捋出整个系统任何一个时间点的状态，这就是Event Sourcing + CQRS的强大之处。

CQRS + Event Sourcing模式还有哪些好处呢？

当查询的并发很高时，数据视图可以有多个副本进一步提升性能；
事件驱动进一步减轻了系统之间的耦合，更容易实现Serverless；
如果某个系统出现BUG，根据历史事件可以追溯出正确的值，要修复脏数据甚至只需要删除当前数据视图即可；
事件驱动天然是可审计的，无需单独的审计日志模块，可以轻易查询出历史执行过的命令，以及命令导致的在各个子系统传播的事件；
更彻底的隔离了读和写，传统的写法如果在find/get中不小心调了update，隐式的副作用往往会导致非常难查的BUG，一切基于命令和事件的思维，能够杜绝读写职责不清晰带来的不确定的副作用。
总结
本文从获取数据变化最简单的轮询方式出发，再分析前后端用来获取实时变化的事件驱动模式，简述了事件驱动模式底层的核心机制——轮询事件队列。

当我们把可复用的轮询藏到底层时，上层就抽象出了一个强大的事件驱动模型，将该模型应用到软件系统的设计层面，又发现了不同于传统CRUD模式的CQRS模式。

虽然CQRS和Event Sourcing有很多好处，但当业务不那么复杂时，CRUD可能仍是更好的方案。CQRS也不是“银弹”：目前没有特别成熟的框架、作为事件中心的消息队列可能成为瓶颈、事件消息的传播途径也会变得极其复杂（甚至从有向无环图变成有环图产生其他问题）、追加写入的事件库可能变得非常庞大、适合CQRS模式的Saga分布式事务更加复杂等等。

https://dblab.xmu.edu.cn/blog/3120/#more-3120